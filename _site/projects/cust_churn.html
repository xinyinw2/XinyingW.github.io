<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-12-10">
<meta name="description" content="Predicts which telecom customers are most likely to leave and explains the key drivers, using supervised models and clear visuals so teams can act on retention quickly.">

<title>Customer Churn Prediction – Xinying Wu’s Portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-0b9a2a02bd90fa1c89e1d56d516cd0b1.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Xinying Wu’s Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../projects/index.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#overview" id="toc-overview" class="nav-link active" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#problem-statement" id="toc-problem-statement" class="nav-link" data-scroll-target="#problem-statement">Problem Statement</a></li>
  <li><a href="#data" id="toc-data" class="nav-link" data-scroll-target="#data">Data</a></li>
  <li><a href="#exploratory-data-analysis" id="toc-exploratory-data-analysis" class="nav-link" data-scroll-target="#exploratory-data-analysis">Exploratory Data Analysis</a></li>
  <li><a href="#tools" id="toc-tools" class="nav-link" data-scroll-target="#tools">Tools</a></li>
  <li><a href="#key-methods-and-approach" id="toc-key-methods-and-approach" class="nav-link" data-scroll-target="#key-methods-and-approach">Key Methods and Approach</a></li>
  <li><a href="#results-and-findings" id="toc-results-and-findings" class="nav-link" data-scroll-target="#results-and-findings">Results and Findings</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#business-implication" id="toc-business-implication" class="nav-link" data-scroll-target="#business-implication">Business Implication</a></li>
  <li><a href="#next-steps" id="toc-next-steps" class="nav-link" data-scroll-target="#next-steps">Next Steps</a></li>
  <li><a href="#links" id="toc-links" class="nav-link" data-scroll-target="#links">Links</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Customer Churn Prediction</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Python</div>
    <div class="quarto-category">Power BI</div>
    <div class="quarto-category">Classification</div>
  </div>
  </div>

<div>
  <div class="description">
    Predicts which telecom customers are most likely to leave and explains the key drivers, using supervised models and clear visuals so teams can act on retention quickly.
  </div>
</div>


<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 10, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="overview" class="level3">
<h3 class="anchored" data-anchor-id="overview">Overview</h3>
<p>This project analyzes customer attrition in the telecom sector using the dataset from Kaggle titled “Customer Churn Prediction:Analysis”. The goal is to discover the factors that most strongly relate to attrition and to build prediction models that flag accounts with high risk. The work translates analytic results into actions that support retention planning, resource allocation, and service improvements. Deliverables include clear explanations of churn drivers, prediction outputs for at-risk customers, and visuals that nontechnical partners can use in planning.</p>
</section>
<section id="problem-statement" class="level3">
<h3 class="anchored" data-anchor-id="problem-statement">Problem Statement</h3>
<p>Telecom firms face revenue loss and higher acquisition cost when customers discontinue service. Without timely prediction, teams respond after the customer has already left, which reduces the effect of retention efforts and can damage brand reputation. The objective is to create an analytic workflow that</p>
<ul>
<li><p>identifies the variables that explain attrition with clarity for business partners</p></li>
<li><p>predicts the probability that each active account will discontinue service in the next period</p></li>
<li><p>provides ranked customer lists with reason codes so teams can act with targeted offers and service interventions</p></li>
</ul>
</section>
<section id="data" class="level3">
<h3 class="anchored" data-anchor-id="data">Data</h3>
<p>This project uses a publicly available telecom customer churn dataset sourced from Kaggle. The dataset provides a comprehensive view of customer behavior and churn in the telecom industry, including customer demographics, service usage, contract attributes, billing amounts, and the churn outcome.</p>
<p><strong>Snapshot</strong></p>
<ul>
<li><p>Records: 1,000 customers</p></li>
<li><p>Features: 10 columns</p></li>
<li><p>Target: Churn yes or no</p></li>
</ul>
<p><strong>Preprocessing summary</strong></p>
<ul>
<li><p>Kept Churn as the dependent variable</p></li>
<li><p>Dropped CustomerID since it carries no predictive signal</p></li>
<li><p>Converted categorical fields to dummy variables for modeling compatibility</p></li>
<li><p>Verified that TotalCharges is approximately MonthlyCharges multiplied by Tenure, with any data quality issues handled during cleaning</p></li>
</ul>
<p><strong>Feature dictionary</strong></p>
<table class="feature-table">
<thead>
<tr>
<th>
Feature
</th>
<th>
Type
</th>
<th>
Description
</th>
<th>
Role
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
CustomerID
</td>
<td>
ID
</td>
<td>
Unique customer key
</td>
<td>
Excluded
</td>
</tr>
<tr>
<td>
Age
</td>
<td>
Numeric
</td>
<td>
Customer age in years
</td>
<td>
Predictor
</td>
</tr>
<tr>
<td>
Gender
</td>
<td>
Categorical
</td>
<td>
Male or Female
</td>
<td>
Predictor
</td>
</tr>
<tr>
<td>
Tenure
</td>
<td>
Numeric
</td>
<td>
Months with provider
</td>
<td>
Predictor
</td>
</tr>
<tr>
<td>
MonthlyCharges
</td>
<td>
Numeric
</td>
<td>
Monthly fee
</td>
<td>
Predictor
</td>
</tr>
<tr>
<td>
ContractType
</td>
<td>
Categorical
</td>
<td>
Month to month, one year, two year
</td>
<td>
Predictor
</td>
</tr>
<tr>
<td>
InternetService
</td>
<td>
Categorical
</td>
<td>
DSL, fiber, or none
</td>
<td>
Predictor
</td>
</tr>
<tr>
<td>
TechSupport
</td>
<td>
Categorical
</td>
<td>
Has support yes or no
</td>
<td>
Predictor
</td>
</tr>
<tr>
<td>
TotalCharges
</td>
<td>
Numeric
</td>
<td>
Total billed amount
</td>
<td>
Predictor
</td>
</tr>
<tr>
<td>
Churn
</td>
<td>
Target
</td>
<td>
Customer left yes or no
</td>
<td>
Target
</td>
</tr>
</tbody>
</table>
</section>
<section id="exploratory-data-analysis" class="level3">
<h3 class="anchored" data-anchor-id="exploratory-data-analysis">Exploratory Data Analysis</h3>
<p>This section summarizes data shape, missing fields, class balance, and key relationships that explain churn.</p>
<img src="p_images/churn_fea2.png" style="float:right; width:40%; margin:0 0 1rem 1rem;">
<p>
</p><p><strong>1. Numeric features distribution</strong><br></p>
<ul>
<li><strong>Age</strong> Most customers are between thirty and fifty years old with an approximately normal shape.<br>
</li>
<li><strong>MonthlyCharges</strong> Values range from about twenty to one hundred twenty, reflecting different service tiers.<br>
</li>
<li><strong>TotalCharges</strong> Values range from zero to around twelve thousand, with most under two thousand. This positive skew suggests many newer or lower cost plans, with a smaller group of long term or premium users.<br>
</li>
<li><strong>Tenure</strong> Spans zero to one hundred twenty months and is concentrated at the lower end, indicating many relatively new customers.
<p></p>
<div style="clear:both;">

</div></li>
</ul>
<img src="p_images/churn_fea3.png" style="float:right; width:40%; margin:0 0 1rem 1rem;">
<p>
</p><p><strong>2. Categorical features distribution</strong><br></p>
<ul>
<li><strong>ContractType</strong> Month to month contracts dominate, suggesting a preference for flexibility.</li>
<li><strong>InternetService</strong> Fiber optic is most common.<br>
</li>
<li><strong>TechSupport</strong> With and without support are close to even.<br>
</li>
<li><strong>Gender</strong> Female is slightly higher than male in this sample.
<p></p>
<div style="clear:both;">

</div></li>
</ul>
<img src="p_images/churn_fea4.png" style="float:right; width:40%; margin:0 0 1rem 1rem;">
<p>
</p><p><strong>3. Target variable distribution</strong><br></p>
<ul>
<li>The <strong>churn target</strong> is imbalanced, with more customers who churned than those who did not. This calls for attention to evaluation choices and possibly class weighting or threshold tuning.
<p></p>
<div style="clear:both;">

</div></li>
</ul>
<img src="p_images/churn_fea2.png" style="float:right; width:40%; margin:0 0 1rem 1rem;">
<p>
</p><p><strong>4. Correlation matrix and key relationships</strong><br></p>
<ul>
<li><strong>Positive</strong> Month to month contracts are strongly associated with higher churn Lack of tech support also aligns with higher churn.</li>
<li><strong>Negative</strong> One year and Two year contracts correlate with lower churn, indicating more loyalty and stability.
<p></p>
<div style="clear:both;">

</div></li>
</ul>
</section>
<section id="tools" class="level3">
<h3 class="anchored" data-anchor-id="tools">Tools</h3>
<p>Modeling and data: <strong>Python</strong> (Pandas, scikit learn, matplotlib, seaborn) <br> Visualization and reporting: <strong>Power BI</strong>, <strong>Excel</strong> <br></p>
</section>
<section id="key-methods-and-approach" class="level3">
<h3 class="anchored" data-anchor-id="key-methods-and-approach">Key Methods and Approach</h3>
<p>This study evaluated five supervised learning models to identify the most accurate method for predicting customer churn. The models include K Nearest Neighbors, Naive Bayes, Logistic Regression, Decision Tree, and Random Forest.</p>
<p><strong>Goal</strong>: Select a reliable predictive method for churn risk with clear business interpretation.</p>
<p><strong>Data variants</strong>: Compare accuracy with original dataset without preprocessing and cleaned dataset with standard preprocessing.</p>
<p><strong>Evaluation</strong>:</p>
<ul>
<li>Overall accuracy<br>
</li>
<li>Precision, recall, and F1 score with special attention to the minority class labeled No<br>
</li>
<li>Practical usefulness for targeted retention actions</li>
</ul>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" role="tab" aria-controls="tabset-1-1" aria-selected="true" href="">K Nearest Neighbors</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-2" role="tab" aria-controls="tabset-1-2" aria-selected="false" href="">Naive Bayes</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-3" role="tab" aria-controls="tabset-1-3" aria-selected="false" href="">Logistic Regression</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-4-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-4" role="tab" aria-controls="tabset-1-4" aria-selected="false" href="">Decision Tree</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-5-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-5" role="tab" aria-controls="tabset-1-5" aria-selected="false" href="">Random Forest</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-1-1-tab">
<p><strong>Objective</strong><br>
Compare a K Nearest Neighbors classifier on the original dataset and on a cleaned dataset to see how preprocessing changes accuracy and class level metrics</p>
<p><strong>Benchmarks</strong></p>
<ul>
<li>Benchmark 1 original dataset without preprocessing<br>
</li>
<li>Benchmark 2 cleaned and preprocessed dataset</li>
</ul>
<p><strong>Evaluation</strong></p>
<ul>
<li>Accuracy<br>
</li>
<li>Precision, recall, and F1 with focus on the minority class labeled No</li>
</ul>
<hr>
</div>
<div id="tabset-1-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-2-tab">
<p><strong>Objective</strong><br>
Assess Naive Bayes on three dataset variants to understand the impact of preprocessing and class balancing</p>
<p><strong>Benchmarks</strong></p>
<ul>
<li>Benchmark 1 original dataset without preprocessing<br>
</li>
<li>Benchmark 2 cleaned and preprocessed dataset<br>
</li>
<li>Benchmark 3 cleaned dataset balanced with SMOTE</li>
</ul>
<p><strong>Evaluation</strong></p>
<ul>
<li>Accuracy<br>
</li>
<li>Precision, recall, and F1 for churned and non churned classes<br>
</li>
<li>Sensitivity to class imbalance</li>
</ul>
<hr>
</div>
<div id="tabset-1-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-3-tab">
<p><strong>Objective</strong><br>
Predict churn using logistic regression and study the effect of preprocessing and threshold tuning on performance and recall</p>
<p><strong>Benchmarks</strong></p>
<ul>
<li>Benchmark 1 model on the unprocessed dataset that includes missing values and unencoded categorical fields<br>
</li>
<li>Benchmark 2 model after preprocessing that fills missing TotalCharges with the mean, scales numeric fields, and applies one hot encoding to categorical fields such as Gender and ContractType<br>
</li>
<li>Benchmark 3 threshold optimization using the ROC curve, selecting a probability cutoff of 0.7 to balance precision and recall</li>
</ul>
<p><strong>Evaluation</strong></p>
<ul>
<li>Accuracy and AUC<br>
</li>
<li>Class level precision, recall, and F1<br>
</li>
<li>Business friendly interpretation through model coefficients</li>
</ul>
<hr>
</div>
<div id="tabset-1-4" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-4-tab">
<p><strong>Objective</strong><br>
Use a classification tree to predict churn and provide rules that are easy for partners to understand</p>
<p><strong>Benchmarks</strong></p>
<ul>
<li>Benchmark 1 model on the original dataset without preprocessing<br>
</li>
<li>Benchmark 2 model on the cleaned and preprocessed dataset<br>
</li>
<li>Benchmark 3 model selection via cross validation to choose depth and split settings that generalize well</li>
</ul>
<p><strong>Evaluation</strong></p>
<ul>
<li>Accuracy and AUC<br>
</li>
<li>Class level precision, recall, and F1<br>
</li>
<li>Feature importance to highlight drivers of churn</li>
</ul>
<hr>
</div>
<div id="tabset-1-5" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-5-tab">
<p><strong>Objective</strong><br>
Improve generalization by averaging many trees and quantify gains from preprocessing and tuning</p>
<p><strong>Benchmarks</strong></p>
<ul>
<li>Benchmark 1 model on the unprocessed dataset with missing values and unencoded categories<br>
</li>
<li>Benchmark 2 model after preprocessing that imputes TotalCharges, standardizes numeric fields, and applies one hot encoding for categories<br>
</li>
<li>Benchmark 3 hyperparameter search to find strong settings for number of trees, depth, and split criteria</li>
</ul>
<p><strong>Evaluation</strong></p>
<ul>
<li>Accuracy and AUC<br>
</li>
<li>Class level precision, recall, and F1<br>
</li>
<li>Feature importance to highlight drivers of churn</li>
</ul>
</div>
</div>
</div>
</section>
<section id="results-and-findings" class="level3">
<h3 class="anchored" data-anchor-id="results-and-findings">Results and Findings</h3>
<p><strong>1. K Nearest Neighbors</strong><br></p>
<table class="metric-table">
<thead>
<tr>
<th>
Metric
</th>
<th>
Original dataset
</th>
<th>
Cleaned dataset
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
Accuracy
</td>
<td>
0.84
</td>
<td>
0.92
</td>
</tr>
<tr>
<td>
Precision for class No
</td>
<td>
0.17
</td>
<td>
0.60
</td>
</tr>
<tr>
<td>
Recall for class No
</td>
<td>
0.80
</td>
<td>
0.94
</td>
</tr>
<tr>
<td>
F1 for class No
</td>
<td>
0.11
</td>
<td>
0.74
</td>
</tr>
<tr>
<td>
Class distribution
</td>
<td>
Yes: 39 No: 261
</td>
<td>
Yes: 39 No: 261
</td>
</tr>
</tbody>
</table>
<p><strong>Findings</strong></p>
<ul>
<li><p>Cleaning the data improved accuracy by eight percentage points</p></li>
<li><p>One hot encoding and binning reduced noise and helped the model learn clearer boundaries</p></li>
<li><p>Upsampling addressed class imbalance and produced very large gains in recall and F1 for the minority class No</p></li>
<li><p>The original data led the model to favor the majority class Yes and missed many true No cases</p></li>
<li><p>The cleaned data produced a more balanced classifier that is useful for retention actions</p></li>
</ul>
<p>Overall KNN performs much better on the cleaned data. Preprocessing and class balancing were essential to identify at risk customers and to achieve balanced performance.</p>
<p><strong>2. Naive Bayes</strong><br></p>
<table class="metric-table">
<thead>
<tr>
<th>
Metric
</th>
<th>
Original dataset
</th>
<th>
Cleaned dataset
</th>
<th>
SMOTE
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
Accuracy
</td>
<td>
0.832
</td>
<td>
0.888
</td>
<td>
0.804
</td>
</tr>
<tr>
<td>
Precision for class Yes
</td>
<td>
0.97
</td>
<td>
0.91
</td>
<td>
0.96
</td>
</tr>
<tr>
<td>
Recall for class Yes
</td>
<td>
0.83
</td>
<td>
0.96
</td>
<td>
0.81
</td>
</tr>
<tr>
<td>
F1 score
</td>
<td>
0.90
</td>
<td>
0.94
</td>
<td>
0.88
</td>
</tr>
<tr>
<td>
Class distribution
</td>
<td>
Yes: 27 No: 181
</td>
<td>
Yes: 13 No: 159
</td>
<td>
Yes: 33 No: 217
</td>
</tr>
</tbody>
</table>
<p><strong>Findings</strong></p>
<ul>
<li><p>Cleaning improved overall accuracy and raised recall for churn class Yes from eighty three percent to ninety six percent</p></li>
<li><p>SMOTE balancing increased recall for the churn class relative to the original data but reduced overall accuracy to zero point eight zero four</p></li>
<li><p>Very high precision on the original data reflects the class imbalance and a conservative decision boundary that missed some true churners</p></li>
<li><p>The cleaned dataset delivered the best balance of accuracy and class level metrics</p></li>
<li><p>Next steps confirm robustness with stratified cross validation, review calibration, and tune the threshold to align recall with retention goals</p></li>
</ul>
<p><strong>3. Logistic Regression</strong><br></p>
<table class="metric-table">
<thead>
<tr>
<th>
Benchmark
</th>
<th>
Accuracy
</th>
<th>
Precision Class 0
</th>
<th>
Recall Class 0
</th>
<th>
F1 score Class 0
</th>
<th>
Class distribution
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
Without preprocessing
</td>
<td>
0.94
</td>
<td>
0.65
</td>
<td>
0.42
</td>
<td>
0.51
</td>
<td>
Yes: 88 No: 12
</td>
</tr>
<tr>
<td>
With preprocessing default
</td>
<td>
0.95
</td>
<td>
0.87
</td>
<td>
0.79
</td>
<td>
0.83
</td>
<td>
Yes: 87 No: 13
</td>
</tr>
<tr>
<td>
With preprocessing optimized threshold
</td>
<td>
0.92
</td>
<td>
0.63
</td>
<td>
1.00
</td>
<td>
0.78
</td>
<td>
Yes: 87 No: 13
</td>
</tr>
</tbody>
</table>
<p><strong>Findings</strong></p>
<ul>
<li><p>Cleaning and encoding improved accuracy from zero point ninety four to zero point ninety five and lifted recall for non churn class zero from forty two percent to seventy nine percent</p></li>
<li><p>Threshold tuning increased recall for class zero to one hundred percent with a tradeoff in precision and overall accuracy to zero point ninety two</p></li>
<li><p>Removing missing values and encoding categories stabilized training and produced more reliable probabilities</p></li>
<li><p>Preprocessed default settings give the best overall balance of accuracy and class level metrics, while the optimized threshold is useful when recall for non churn must be maximized for a specific business rule</p></li>
</ul>
<p><strong>4. Decision Tree</strong><br></p>
<table class="metric-table">
<thead>
<tr>
<th>
Metric
</th>
<th>
Original dataset
</th>
<th>
Cleaned dataset
</th>
<th>
Cross-validation
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
Accuracy
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
</tr>
<tr>
<td>
Precision for class No
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
</tr>
<tr>
<td>
Recall for class No
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
</tr>
<tr>
<td>
F1 for class No
</td>
<td>
1
</td>
<td>
1
</td>
<td>
1
</td>
</tr>
<tr>
<td>
Class distribution
</td>
<td>
Yes: 27 No: 223
</td>
<td>
Yes: 32 No: 144
</td>
<td>
Yes: 30 No: 150
</td>
</tr>
</tbody>
</table>
<p><strong>Findings</strong></p>
<ul>
<li><p>Accuracy, precision, recall, and F1 were all one hundred percent on both original and cleaned data</p></li>
<li><p>Heavy class imbalance with about eighty eight percent Yes likely inflated the metrics and reduced generalization</p></li>
<li><p>Preprocessing did not change the winning features, but it shifted their relative importance</p></li>
</ul>
<p><strong>5. Random Forest</strong><br></p>
<table class="metric-table">
<thead>
<tr>
<th>
Metric
</th>
<th>
Original dataset
</th>
<th>
Cleaned dataset
</th>
<th>
Hyperparameter tuning
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
Accuracy
</td>
<td>
0.96
</td>
<td>
1.0
</td>
<td>
0.996
</td>
</tr>
<tr>
<td>
Precision
</td>
<td>
~1.0
</td>
<td>
1.0
</td>
<td>
1.0
</td>
</tr>
<tr>
<td>
Recall
</td>
<td>
~1.0
</td>
<td>
1.0
</td>
<td>
1.0
</td>
</tr>
<tr>
<td>
F1 score
</td>
<td>
~1.0
</td>
<td>
1.0
</td>
<td>
1.0
</td>
</tr>
<tr>
<td>
Train score
</td>
<td>
1.0
</td>
<td>
1.0
</td>
<td>
1.0
</td>
</tr>
<tr>
<td>
Test score
</td>
<td>
0.96
</td>
<td>
1.0
</td>
<td>
0.996
</td>
</tr>
<tr>
<td>
Class distribution
</td>
<td>
Yes: 27<br>No: 223
</td>
<td>
Yes: 33<br>No: 217
</td>
<td>
Yes: 33<br>No: 216
</td>
</tr>
</tbody>
</table>
<p><strong>Findings</strong></p>
<ul>
<li><p>Preprocessing raised accuracy from zero point ninety six to one point zero and produced perfect precision, recall, and F1</p></li>
<li><p>Filling missing TotalCharges and encoding categories reduced noise and likely helped the trees form cleaner splits</p></li>
<li><p>Class balance shifted slightly toward Yes after cleaning, yet the target remains imbalanced near eighty six percent Yes</p></li>
<li><p>Perfect metrics across train and test suggest limited stress on generalization; validate with stratified cross validation and report balanced accuracy and AUC</p></li>
<li><p>Hyperparameter tuning delivered accuracy of zero point nine nine six with other metrics unchanged, confirming a strong and stable model while still warranting checks for robustness on unseen data</p></li>
</ul>
</section>
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion">Conclusion</h3>
<p>Our comparison shows that Decision Tree and Random Forest reached near perfect accuracy, while KNN and Logistic Regression also performed strongly at around the low to mid nineties. Naive Bayes trailed at about eighty eight percent on the cleaned data. Cross validation and confusion matrix checks did not indicate overfitting for the tree models, though the class imbalance means we should continue to validate with balanced accuracy and AUC on true holdouts.</p>
<p>For production use, pair one tree based model with one non tree model to balance strengths and reduce risk from unseen patterns. For example, deploy a Decision Tree or Random Forest alongside a KNN or Logistic Regression model, monitor both, and choose actions when they agree or when calibrated churn risk exceeds a threshold. With these models, a telecom company can flag at risk customers early and trigger targeted retention steps such as personalized discounts, proactive service outreach, and plan reviews to protect revenue and improve satisfaction.</p>
</section>
<section id="business-implication" class="level3">
<h3 class="anchored" data-anchor-id="business-implication">Business Implication</h3>
<div class="columns">
<div class="column" style="width:50%;">
<p><strong>Revenue and retention</strong></p>
<ul>
<li>Reduce churn through early outreach</li>
<li>Lift lifetime value with right sized plans</li>
<li>Shift spend from broad ads to focused saves</li>
</ul>
<p><strong>Operations and service</strong></p>
<ul>
<li>Route high risk accounts to priority care</li>
<li>Trigger proactive outreach after tickets or outages</li>
<li>Set stronger service targets for high risk segments</li>
</ul>
</div><div class="column" style="width:50%;">
<p><strong>Marketing and offers</strong></p>
<ul>
<li>Personalize incentives by churn driver</li>
<li>Run win back campaigns on persisting risk</li>
<li>Use uplift testing to target customers who respond</li>
</ul>
<p><strong>Planning and governance</strong></p>
<ul>
<li>Forecast churn driven revenue and program ROI</li>
<li>Monitor fairness by segment and keep decision logs</li>
<li>Integrate scores into CRM with clear reason codes</li>
</ul>
</div>
</div>
</section>
<section id="next-steps" class="level3">
<h3 class="anchored" data-anchor-id="next-steps">Next Steps</h3>
<p>Our results are strong, but the target class is very imbalanced and Naive Bayes underperformed. This limits confidence in real world performance and suggests that the current metrics may be inflated by class skew. To help improve our models, we should consider the following steps:</p>
<ul>
<li><strong>Data and labeling</strong>
<ul>
<li>Collect more recent records to reduce class skew and reflect current behavior</li>
<li>Balance the target using resampling or class weights and compare to the current baseline</li>
<li>Audit labels and remove duplicates that can inflate accuracy</li>
</ul></li>
<li><strong>Validation and metrics</strong>
<ul>
<li>Use stratified cross validation with a true holdout set</li>
<li>Add balanced accuracy, Matthews correlation, AUC ROC, and AUC PR</li>
<li>Use time based validation if the data has a natural timeline</li>
</ul></li>
<li><strong>Model robustness and calibration</strong>
<ul>
<li>Calibrate probabilities for better threshold control</li>
<li>Tune thresholds by segment to meet business goals such as higher recall for churners</li>
<li>For Naive Bayes, add interaction features or consider a variant that handles continuous features more flexibly</li>
<li>Add a gradient boosted tree as an additional comparator</li>
</ul></li>
<li><strong>Feature quality and leakage checks</strong>
<ul>
<li>Standardize numeric fields and encode categorical fields consistently</li>
<li>Keep binning only where it helps</li>
<li>Recheck for target leakage and confirm drivers with permutation importance and SHAP</li>
</ul></li>
<li><strong>Monitoring and operations</strong>
<ul>
<li>Track live KPIs such as monthly churn rate, save rate, net revenue saved, offer cost per save, and calibration error</li>
<li>Log predictions with reason codes in the CRM so agents see top drivers</li>
<li>Schedule retraining and drift checks on a regular cadence</li>
</ul></li>
<li><strong>Summary action</strong>
<ul>
<li>Deploy one tree model and one non tree model in parallel</li>
<li>Calibrate and monitor both, then re evaluate once additional balanced data is available</li>
</ul></li>
</ul>
</section>
<section id="links" class="level3">
<h3 class="anchored" data-anchor-id="links">Links</h3>
<p><strong>Dataset Source:</strong><br>
<a href="https://www.kaggle.com/datasets/abdullah0a/telecom-customer-churn-insights-for-analysis">Customer Churn Dataset on Kaggle</a></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>